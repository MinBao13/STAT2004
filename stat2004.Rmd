

```{r}
# --- PART 1: COMPLETE DATA PREPARATION (FINAL ROBUST VERSION + DEBUGGING) ---

# A. Data Import and Numeric Selection
data <- readxl::read_excel("AirQualityUCI.xlsx")
data_numeric <- as.data.frame(data[, 3:15]) # Convert to standard data.frame

# B. Data Cleaning: MANUAL TYPE CONVERSION (Fixing comma decimals)
for (i in 1:ncol(data_numeric)) {
  data_numeric[, i] <- as.character(data_numeric[, i])
  data_numeric[, i] <- gsub(",", ".", data_numeric[, i])
  data_numeric[, i] <- as.numeric(data_numeric[, i])
}

# C. Imputation and Unit Conversion
data_clean <- data_numeric

# CRITICAL FIX 1: Convert the dataset's missing marker (-200) to NA
# This must happen before imputation.
data_clean[data_clean == -200] <- NA

# 1. Mean Imputation (Handles NA values, including the ones we just created)
for (i in 1:ncol(data_clean)) {
  current_mean <- mean(data_clean[, i], na.rm = TRUE)
  data_clean[is.na(data_clean[, i]), i] <- current_mean
}

# --- FINAL CORRECTION TO PART 1 (Unit Conversion) ---

# CRITICAL FIX 1: Convert the dataset's missing marker (-200) to NA
# This must happen before imputation.
data_clean[data_clean == -200] <- NA

# 1. Mean Imputation (Handles NA values, including the ones we just created)
for (i in 1:ncol(data_clean)) {
  current_mean <- mean(data_clean[, i], na.rm = TRUE)
  data_clean[is.na(data_clean[, i]), i] <- current_mean
}

# FIX 2: Ozone Unit Conversion (Using the correct column name: PT08.S5(O3))
data_clean$`PT08.S5(O3)` <- (data_clean$`PT08.S5(O3)` * 0.51) / 1000

print("✅ Part 1: Data Preparation Complete. ALL errors fixed.")
print(paste("Final Cleaned Data Dimensions:", paste(dim(data_clean), collapse = "x")))

```
```{r}
# --- PART 2-A: Define AQI Breakpoints and IP Calculation Function (FIXED) ---

# 1. FIXED AQI Breakpoints (Ozone column name updated to PT08.S5(O3))
aqi_breakpoints <- data.frame(
  Pollutant = c(rep("PT08.S5(O3)", 7), rep("CO(GT)", 7), rep("PT08.S3(NOx)", 7)), 
  BP_Lo = c(0.000, 0.055, 0.071, 0.086, 0.106, 0.205, 0.405, 
            0.0, 4.5, 9.5, 12.5, 15.5, 30.5, 40.5, 
            0, 54, 101, 361, 650, 1250, 1650), 
  BP_Hi = c(0.054, 0.070, 0.085, 0.105, 0.204, 0.404, 0.604, 
            4.4, 9.4, 12.4, 15.4, 30.4, 40.4, 50.4, 
            53, 100, 360, 649, 1249, 1649, 2049),
  I_Lo = c(0, 51, 101, 151, 201, 301, 401, 0, 51, 101, 151, 201, 301, 401, 0, 51, 101, 151, 201, 301, 401),
  I_Hi = c(50, 100, 150, 200, 300, 400, 500, 50, 100, 150, 200, 300, 400, 500, 50, 100, 150, 200, 300, 400, 500)
)
# Note: I've also updated CO and NOx names based on your debug output for consistency
pollutant_cols <- unique(aqi_breakpoints$Pollutant)


# 2. Function to calculate the Individual Pollutant Index (Ip) - REMAINS UNCHANGED
calculate_ip <- function(Cp, pollutant_name, aqi_breakpoints) {
  if (is.na(Cp) || Cp < 0) return(NA)
  pollutant_bps <- aqi_breakpoints[aqi_breakpoints$Pollutant == pollutant_name, ]
  matched_row <- pollutant_bps[pollutant_bps$BP_Lo <= Cp & Cp <= pollutant_bps$BP_Hi, ]
  
  if (nrow(matched_row) != 1) {
    if (Cp > max(pollutant_bps$BP_Hi)) { matched_row <- pollutant_bps[which.max(pollutant_bps$BP_Hi), ] } else { return(NA) }
  }
  I_Hi <- matched_row$I_Hi[1]; I_Lo <- matched_row$I_Lo[1]
  BP_Hi <- matched_row$BP_Hi[1]; BP_Lo <- matched_row$BP_Lo[1]
  Ip <- max(0, ((I_Hi - I_Lo) / (BP_Hi - BP_Lo)) * (Cp - BP_Lo) + I_Lo)
  return(Ip)
}
print("AQI Breakpoints and Calculation Function Defined with correct names.")
```

```{r}
# --- PART 2-B: Calculate Individual Pollutant Indices ---
for (col in pollutant_cols) {
  # This uses the correct names from pollutant_cols
  data_clean[[paste0("AQI_", col)]] <- as.numeric(sapply(data_clean[[col]], calculate_ip, pollutant_name = col, aqi_breakpoints = aqi_breakpoints))
}

aqi_columns <- grep("^AQI_", names(data_clean), value = TRUE)
print(paste("Individual AQI columns created:", paste(aqi_columns, collapse = ", ")))
```
```{r}
# --- PART 2-C: Calculate Overall AQI and Level ---

# 1. Calculate Overall AQI (Maximum of all individual pollutant AQI values)
data_clean$AQI <- apply(data_clean[, aqi_columns, drop = FALSE], 1, max, na.rm = TRUE) 
data_clean$AQI[is.infinite(data_clean$AQI)] <- NA

# 2. Create the classification variable (AQI_Level)
data_clean$AQI_Level <- cut(data_clean$AQI,
                            breaks = c(-Inf, 50, 100, 150, 200, 300, 400, 500, Inf),
                            labels = c("Good", "Moderate", "Unhealthy for specific groups", "Unhealthy", "Very unhealthy", "Hazardous", "Hazardous", "Undefined"),
                            right = TRUE, include.lowest = TRUE)

print("✅ Overall AQI Calculation Complete.")
print(head(data_clean[, c("AQI", "AQI_Level", "CO(GT)", "PT08.S5(O3)", "PT08.S3(NOx)")]))
```

```{r}
# --- PART 3: RANDOM FOREST CLASSIFICATION MODEL (FIXED FOR SPECIAL CHARACTERS) ---

# NOTE: This code assumes the data frame 'data_clean' exists and contains the AQI_Level column.

# 1. Load the required library
# Run this line once if you haven't installed it yet: install.packages("randomForestSRC")
if (!require(randomForestSRC)) library(randomForestSRC)

# 2. Data Preparation: Define Predictors and Target
target_variable <- "AQI_Level"

# The predictor names are the original names from data_clean (1 to 13)
predictor_columns <- names(data_clean)[1:13]

# CRITICAL FIX: Wrap column names in backticks (`) to handle the parentheses
quoted_predictors <- paste0("`", predictor_columns, "`")

# Create the final formula using the backticked names
model_formula <- as.formula(paste(target_variable, "~", paste(quoted_predictors, collapse = " + ")))

# 3. Data Split (Training and Testing Sets)
set.seed(42) # For reproducibility
train_index <- sample(1:nrow(data_clean), size = 0.7 * nrow(data_clean)) # 70% for training
train_data <- data_clean[train_index, ]
test_data <- data_clean[-train_index, ]

# 4. Model Training
print("Starting Random Forest Model Training...")

# Train the classification model using rfsrc
rf_model <- rfsrc(
  model_formula, 
  data = train_data, 
  ntree = 500,
  importance = "none",
  seed = 42
)

print("✅ Random Forest Model Training Complete.")
print("Model Summary:")
print(rf_model)

```
```{r}
# --- PART 4: MODEL EVALUATION ---

# Requires 'rf_model' and 'test_data' from the previous step.

# 1. Prediction on the test set
print("Starting prediction on test data...")
rf_predictions <- predict(rf_model, newdata = test_data)

# Extract the predicted class labels
predicted_classes <- rf_predictions$class

# 2. Create the Confusion Matrix
# Ensure both Actual and Predicted variables are factors with the same levels
actual_classes <- test_data$AQI_Level
# Use the levels from the training data to ensure consistency
levels(predicted_classes) <- levels(actual_classes)

# Base R table function for Confusion Matrix
confusion_matrix <- table(Actual = actual_classes, Predicted = predicted_classes)

# 3. Calculate Overall Accuracy
accuracy <- sum(diag(confusion_matrix)) / sum(confusion_matrix)

print("✅ Model Evaluation Complete.")
print("--- Confusion Matrix (Test Data) ---")
print(confusion_matrix)
print("-----------------------------------")
print(paste("Overall Accuracy on Test Set:", round(accuracy, 4)))
```

```{r}
# --- PART 5: VARIABLE IMPORTANCE (Final Robust Version) ---

# 1. Rerun Model with Importance Calculation (if not done in the previous step)
# This step ensures the importance scores were computed during training.
print("Ensuring Model is trained with Importance...")
rf_model_importance <- rfsrc(
  model_formula, 
  data = train_data, 
  ntree = 500,
  importance = "permute", 
  seed = 42
)

# 2. Extract Importance Scores by filtering the class labels
# The VIMP matrix has a column for each class. We only care about observed classes.
importance_matrix <- rf_model_importance$importance

# Identify the columns (classes) that actually have data (non-zero frequency)
# Based on your output, these are: Very unhealthy, Hazardous, Undefined
observed_classes <- c("Very unhealthy", "Hazardous", "Undefined")

# Extract the importance columns only for the observed classes
vimp_observed <- importance_matrix[, observed_classes]

# Calculate the overall VIMP by taking the mean (or max) across the observed classes
# We will take the mean for a general measure of variable power.
overall_vimp <- rowMeans(vimp_observed)

# 3. Create the final data frame and sort
vimp_scores <- data.frame(
  Variable = names(overall_vimp),
  VIMP = overall_vimp,
  row.names = NULL
)

# Sort by VIMP score (highest is most important)
vimp_scores <- vimp_scores[order(vimp_scores$VIMP, decreasing = TRUE), ]

print("✅ Variable Importance Calculation Complete (Robust Method).")
print("Top 5 Most Important Predictors (Overall Mean VIMP):")
print(head(vimp_scores, 5))
```

```{r}
# --- FINAL PLOT: VARIABLE IMPORTANCE BAR CHART (BASE R GRAPHICS) ---

# NOTE: This code requires the 'vimp_scores' data frame created in the last step.

# Sort the data frame by VIMP score (it should already be sorted, but ensures order)
vimp_scores <- vimp_scores[order(vimp_scores$VIMP), ]

# 1. Prepare Plotting Area
# Increase the margin on the left side (7) to fit the variable names
par(mar = c(5, 7, 4, 2) + 0.1) 

# 2. Create the Bar Chart
barplot(
    vimp_scores$VIMP,
    names.arg = vimp_scores$Variable,
    horiz = TRUE, # Draw bars horizontally
    las = 1,     # Rotate y-axis labels horizontally for readability
    col = hcl.colors(nrow(vimp_scores), "SunsetDark"), # Use a nice color palette
    main = "Variable Importance for Predicting AQI Level",
    xlab = "Overall Variable Importance (VIMP)",
    ylab = "",   # Y-axis label is the variable name
    cex.names = 0.9 # Shrink variable name font size slightly
)

# 3. Add Title and Labels
title(sub = "Calculated using Mean VIMP of Observed Classes")

# Reset margins to default 
par(mar = c(5, 4, 4, 2) + 0.1)

print("✅ Final Variable Importance Plot code executed.")
```

