---
title: "Untitled"
output: html_document
date: '2025-10-17'
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

## R Markdown

This is an R Markdown document. Markdown is a simple formatting syntax for authoring HTML, PDF, and MS Word documents. For more details on using R Markdown see <http://rmarkdown.rstudio.com>.

When you click the **Knit** button a document will be generated that includes both content as well as the output of any embedded R code chunks within the document. You can embed an R code chunk like this:



# --- Impute Data ---

```{r}
library(dplyr)
library(randomForestSRC)
library(MASS)
```

```{r}
Pollute <- readxl::read_excel("AirQualityUCI.xlsx")
```

```{r}
pollutants <- c(3:15)
Pollute[pollutants] <- lapply(Pollute[pollutants], function(x) na_if(x, -200))
```

```{r}
Pollute1 <- Pollute[3:15]
```

#Impute using random forest
```{r}
rf_imp <- rfsrc(data = Pollute1, nodesize = 1, nsplit = 10, nimpute = 2, na.action = "na.impute")
```

#Extract the imputed data
```{r}
ImputedPollute <- rf_imp$xvar
```

# --- Unit Conversion ---

```{r}
#Converters 
mgm3_CO <- function(C, temperature = 25, pressure = 1) {
  # C: concentration in mg/m³
  # temperature: °C (default 25°C)
  # pressure: atm (default 1 atm)
  
  mol_weight <- 28.01  # g/mol for CO
  T <- temperature + 273.15  # Convert to Kelvin
  
  # Conversion formula
  ppm <- (C * 24.45 * pressure) / (mol_weight * (T / 298))
  
  return(ppm)
}

microg_NO2 <- function(C, temperature = 25, pressure = 1) {
  # C: concentration in µg/m³
  # temperature: °C (default 25°C)
  # pressure: atm (default 1 atm)
  
  mol_weight <- 46.01  # g/mol for NO2
  T <- temperature + 273.15  # convert to Kelvin
  
  # Convert µg/m³ to mg/m³ first
  mg_m3 <- C / 1000
  
  # Conversion formula:
  # ppm = (mg/m³ * 24.45 * (P / 1 atm)) / (MW * (T / 298 K))
  ppm <- (mg_m3 * 24.45 * pressure) / (mol_weight * (T / 298))
  
  # Convert ppm → ppb
  ppb <- ppm * 1000
  
  return(ppb)
}
```

```{r}
# Apply conversion to dataset
ConvertedPollute <- ImputedPollute %>%
  mutate(
    `CO(GT)` = mgm3_CO(`CO(GT)`),       # Convert CO from mg/m³ to ppm
    `NO2(GT)` = microg_NO2(`NO2(GT)`)   # Convert NO2 from µg/m³ to ppb
  )
```

# --- Calculate AQI ---

```{r}
# AQI calculator returning both AQI value and category
AQI <- function(P){
  # Extract pollutant vectors
  CO  <- P$CO
  NO2 <- P$NO2 

  # --- Breakpoint tables ---
  CO_bp <- data.frame(
    c_lo = c(0.0, 4.5,  9.5, 12.5, 15.5, 30.5, 40.5),
    c_hi = c(4.4, 9.4, 12.4, 15.4, 30.4, 40.4, 50.4),
    i_lo = c(  0,  51, 101, 151, 201, 301, 401),
    i_hi = c( 50, 100, 150, 200, 300, 400, 500)
  )

  NO2_bp <- data.frame(
    c_lo = c(   0,   54,  101,  361,   650,  1250,  1650),
    c_hi = c(  53,  100,  360,  649,  1249,  1649,  2049),
    i_lo = c(   0,   51,  101,  151,   201,   301,   401),
    i_hi = c(  50,  100,  150,  200,   300,   400,   500)
  )

  # --- Helper: subindex interpolation ---
  calc_subindex <- function(C, bp) {
    sapply(C, function(cval) {
      r <- which(cval >= bp$c_lo & cval <= bp$c_hi)[1]
      with(bp[r, ], (i_hi - i_lo) / (c_hi - c_lo) * (cval - c_lo) + i_lo)
    })
  }

  # --- Compute subindices and overall AQI ---
  aqi_co  <- calc_subindex(CO,  CO_bp)
  aqi_no2 <- calc_subindex(NO2, NO2_bp)
  max_aqi <- pmax(aqi_co, aqi_no2)

  # --- AQI categories ---
  category <- cut(
    max_aqi,
    breaks = c(-Inf, 50, 100, 150, 200, 300, 400, Inf),
    labels = c("Good", "Moderate", "Unhealthy (Sensitive)",
               "Unhealthy", "Very Unhealthy", "Hazardous", "Extremely Hazardous"),
    right = TRUE
  )

  # --- Return both AQI and category ---
  data.frame(
    AQI = round(max_aqi, 2),
    Category = category
  )
}

df <- data.frame(CO = ConvertedPollute$`CO(GT)`, NO2 = ConvertedPollute$`NO2(GT)`)  

AQI_results <- AQI(df)
ConvertedPollute$AQI <- AQI_results$AQI
ConvertedPollute$AQI_level <- AQI_results$Category
```

```{r}
rf_imp <- rfsrc(data = ConvertedPollute, nodesize = 1, nsplit = 10, nimpute = 2, na.action = "na.impute")
```

```{r}
ConvertedPollute <- rf_imp$xvar
```
```{r}
# --- PART 3: RANDOM FOREST CLASSIFICATION MODEL (FIXED FOR SPECIAL CHARACTERS) ---

# NOTE: This code assumes the data frame 'data_clean' exists and contains the AQI_Level column.

# 1. Load the required library
# Run this line once if you haven't installed it yet: install.packages("randomForestSRC")
if (!require(randomForestSRC)) library(randomForestSRC)

# 2. Data Preparation: Define Predictors and Target
target_variable <- "AQI_Level"

# The predictor names are the original names from data_clean (1 to 13)
predictor_columns <- names(data_clean)[1:13]

# CRITICAL FIX: Wrap column names in backticks (`) to handle the parentheses
quoted_predictors <- paste0("`", predictor_columns, "`")

# Create the final formula using the backticked names
model_formula <- as.formula(paste(target_variable, "~", paste(quoted_predictors, collapse = " + ")))

# 3. Data Split (Training and Testing Sets)
set.seed(42) # For reproducibility
train_index <- sample(1:nrow(data_clean), size = 0.7 * nrow(data_clean)) # 70% for training
train_data <- data_clean[train_index, ]
test_data <- data_clean[-train_index, ]

# 4. Model Training
print("Starting Random Forest Model Training...")

# Train the classification model using rfsrc
rf_model <- rfsrc(
  model_formula, 
  data = train_data, 
  ntree = 500,
  importance = "none",
  seed = 42
)

print("✅ Random Forest Model Training Complete.")
print("Model Summary:")
print(rf_model)

```
```{r}
# --- PART 4: MODEL EVALUATION ---

# Requires 'rf_model' and 'test_data' from the previous step.

# 1. Prediction on the test set
print("Starting prediction on test data...")
rf_predictions <- predict(rf_model, newdata = test_data)

# Extract the predicted class labels
predicted_classes <- rf_predictions$class

# 2. Create the Confusion Matrix
# Ensure both Actual and Predicted variables are factors with the same levels
actual_classes <- test_data$AQI_Level
# Use the levels from the training data to ensure consistency
levels(predicted_classes) <- levels(actual_classes)

# Base R table function for Confusion Matrix
confusion_matrix <- table(Actual = actual_classes, Predicted = predicted_classes)

# 3. Calculate Overall Accuracy
accuracy <- sum(diag(confusion_matrix)) / sum(confusion_matrix)

print("✅ Model Evaluation Complete.")
print("--- Confusion Matrix (Test Data) ---")
print(confusion_matrix)
print("-----------------------------------")
print(paste("Overall Accuracy on Test Set:", round(accuracy, 4)))
```

```{r}
# --- PART 5: VARIABLE IMPORTANCE (Final Robust Version) ---

# 1. Rerun Model with Importance Calculation (if not done in the previous step)
# This step ensures the importance scores were computed during training.
print("Ensuring Model is trained with Importance...")
rf_model_importance <- rfsrc(
  model_formula, 
  data = train_data, 
  ntree = 500,
  importance = "permute", 
  seed = 42
)

# 2. Extract Importance Scores by filtering the class labels
# The VIMP matrix has a column for each class. We only care about observed classes.
importance_matrix <- rf_model_importance$importance

# Identify the columns (classes) that actually have data (non-zero frequency)
# Based on your output, these are: Very unhealthy, Hazardous, Undefined
observed_classes <- c("Very unhealthy", "Hazardous", "Undefined")

# Extract the importance columns only for the observed classes
vimp_observed <- importance_matrix[, observed_classes]

# Calculate the overall VIMP by taking the mean (or max) across the observed classes
# We will take the mean for a general measure of variable power.
overall_vimp <- rowMeans(vimp_observed)

# 3. Create the final data frame and sort
vimp_scores <- data.frame(
  Variable = names(overall_vimp),
  VIMP = overall_vimp,
  row.names = NULL
)

# Sort by VIMP score (highest is most important)
vimp_scores <- vimp_scores[order(vimp_scores$VIMP, decreasing = TRUE), ]

print("✅ Variable Importance Calculation Complete (Robust Method).")
print("Top 5 Most Important Predictors (Overall Mean VIMP):")
print(head(vimp_scores, 5))
```

```{r}
# --- FINAL PLOT: VARIABLE IMPORTANCE BAR CHART (BASE R GRAPHICS) ---

# NOTE: This code requires the 'vimp_scores' data frame created in the last step.

# Sort the data frame by VIMP score (it should already be sorted, but ensures order)
vimp_scores <- vimp_scores[order(vimp_scores$VIMP), ]

# 1. Prepare Plotting Area
# Increase the margin on the left side (7) to fit the variable names
par(mar = c(5, 7, 4, 2) + 0.1) 

# 2. Create the Bar Chart
barplot(
    vimp_scores$VIMP,
    names.arg = vimp_scores$Variable,
    horiz = TRUE, # Draw bars horizontally
    las = 1,     # Rotate y-axis labels horizontally for readability
    col = hcl.colors(nrow(vimp_scores), "SunsetDark"), # Use a nice color palette
    main = "Variable Importance for Predicting AQI Level",
    xlab = "Overall Variable Importance (VIMP)",
    ylab = "",   # Y-axis label is the variable name
    cex.names = 0.9 # Shrink variable name font size slightly
)

# 3. Add Title and Labels
title(sub = "Calculated using Mean VIMP of Observed Classes")

# Reset margins to default 
par(mar = c(5, 4, 4, 2) + 0.1)

print("✅ Final Variable Importance Plot code executed.")
```


